# 多道程序分时多任务

在第四节，我们讨论了多道程序分时多任务系统。在深入讲解这一主题前，让我们先了解一些背景知识。

## 背景

1. **硬件发展**：随着硬件技术的发展，内存容量不断增大，CPU的速度不断提升。此时，软件应尽可能让CPU保持忙碌，以充分利用其性能。一个重要的转变在于大型机OS/360中引入的多道批处理模式。随着内存容量的提升，系统可以同时在内存中容纳多个程序，从而提高CPU的利用率。

2. **计算机类型变化**：大型机逐渐向小型机过渡，计算机应用的范围越来越广泛。用户希望与计算机实现更好的交互，批处理模式难以满足这种需求，因此分时系统逐渐普及，使用户能够更好地进行程序调试和开发。

3. **术语的多样性**：多道程序分时多任务系统的讨论中会出现大量术语，如“job”、“task”、“process”等。这些词汇在不同阶段和场景中有细微的差异，但总体上都描述了应用程序的执行过程。IBM的调度算法中明确提到“job”一词，而没有直接提到“process”。这些术语的细微差异无需纠结，但需要理解其背后的概念。

## 多道程序带来的问题

1. **CPU调度**：在多道程序中，如何分配CPU资源成为一个关键问题。最初，系统采取非抢占式的方式，由应用程序自行决定何时放弃CPU。然而，为防止程序陷入死循环导致资源浪费，现代操作系统普遍使用抢占式调度，使操作系统能够控制CPU的分配。

2. **分时系统的实现**：MIT研发的多种计算机系统中都具备抢占机制，以实现分时任务的处理，保障多用户和多任务的需求。

## Task与Process

在多道程序分时多任务系统中，我们常提到“task”和“process”两个概念。它们都描述了应用程序的执行过程，任务被分割成多个时间片。每个时间片在不同任务间切换，形成完整的任务执行过程。







# 操作系统中的任务与进程

在操作系统的发展过程中，任务和进程的定义和使用逐渐清晰化。以下是对任务和进程概念以及相关机制的深入总结。

## 任务的定义

任务被定义为具有独立功能的程序在一个数据集合上动态执行的过程，它是进程的前身。任务不管理太多资源，而进程则更加复杂，负责管理资源。任务的执行过程由时间片组成，在每个时间片中执行任务或保持空闲状态。

- **计算任务片**：在时间片上执行某一计算任务的时间段。
- **空闲任务片**：时间片处于空闲状态，不执行计算任务。

时间片用于分配CPU的执行时间，在不同任务之间切换。任务切换的频率过高会影响系统效率，但为了充分利用CPU资源，操作系统必须定期在任务之间切换。

## 抢占式调度

抢占式调度机制由操作系统控制，应用程序无需自行管理CPU的释放。操作系统通过时间片机制确保在某个时间片执行任务，在下一个时间片暂停执行。应用程序对这一切换过程完全透明，并未感知到任务切换。

- **操作系统的假象**：应用程序会误认为自己占用整个处理器，尽管其他程序正在“偷偷”使用时间片。由于切换速度极快，应用程序难以察觉。

## 任务与进程的概念争议

术语“任务”和“进程”在不同环境下的使用可能会引起争议。虽然“进程”更常见，但历史上“任务”先出现，其合理性也受到操作系统实际应用的支持。

- **Windows任务管理器**：在Windows系统中，任务管理器用于查看和管理任务，而非称为“进程管理器”。
- **Linux Top命令**：在Linux系统中，Top命令显示系统任务的数量与状态，同样称为任务而非进程。

虽然操作系统教材多使用“进程”一词，但在实践中“任务”仍有广泛使用。历史上，任务管理是先于进程概念而存在的，体现出操作系统发展中的合理性与连续性。







# 任务的特点与任务和程序的关系

在操作系统中，任务具有一些关键特点，这些特点将任务与进程区分开，并且明确了任务与程序的关系。

## 任务的特点

1. **切换性**：任务能够在不同任务之间切换，每个任务拥有自己独立的执行控制流。

2. **动态性**：任务的执行过程是动态的，在执行时可能会中断或暂停。

3. **并发性**：在一段时间内，多个任务可以同时运行，形成并发的执行环境。

4. **独立性**：任务之间并不感知彼此的存在，而操作系统需要管理和感知所有任务的状态。

5. **弱隔离性**：与进程相比，任务的隔离性不够彻底，缺乏独立的地址空间。

6. **缺乏灵活性**：任务无法像进程一样具备灵活的管理功能，例如创建新的任务等。

这些特点将任务与进程区分开来，使任务成为进程的前身。

## 任务与程序的关系

1. **程序的定义**：程序是静态的代码，无论是源代码还是可执行文件，都是一种静态的文件。

2. **任务的定义**：任务是程序在内存中的动态执行过程，操作系统会将程序加载到内存中，并执行其中的代码。

3. **执行状态**：执行状态指的是任务在执行过程中对内存、寄存器等资源的修改。由于任务的执行状态不断变化，因此同一个程序的不同执行过程可能呈现出不同的任务执行状态。

4. **资源需求**：任务的执行主要需要两种资源：CPU和内存。

5. **程序与任务的区别**：
   - 程序是静态的，而任务是动态的。
   - 程序是永久的文件，而任务是暂时的执行过程。
   - 程序和任务的组成不同，任务在执行过程中具有自己的内存空间和控制流。

## 小结

任务是程序的执行过程，在执行中具有动态性、并发性和独立性。程序作为静态文件提供了执行的基础，而任务通过加载程序代码并运行在内存中，将程序的静态代码转化为动态的执行状态。尽管任务是暂时的，但它体现了程序的真正功能，进一步明确了任务与程序的区别与联系。





# 任务的组成与管理

在操作系统中，任务的管理需要确保系统能够在执行过程中有效切换任务，并保持执行的一致性。为此，任务的组成和状态信息管理显得尤为重要。

## 任务的组成

任务在执行过程中包含一些状态信息，这些信息在特定时刻被系统记录下来，以实现任务切换。具体而言，任务状态包括：

1. **控制流**：控制流指示任务当前执行的具体位置。通过程序计数器（PC），系统能够跟踪任务代码执行的具体位置，以便在恢复任务时继续从中断点执行。

2. **数据状态**：任务访问的数据包括内存和寄存器。其中，内存可进一步划分为堆、栈、数据段等部分。寄存器则保存了任务执行的各种临时数据。

在任务被中断或暂停时，操作系统需要保存任务的上下文，包括控制流、寄存器状态等，以便在任务切换时正确恢复。这种上下文保存被称为任务上下文切换，需包括：

- **程序计数器**：记录任务执行的具体代码位置。
- **栈地址**：保存任务当前的栈指针位置。
- **通用寄存器**：保存任务执行中需要恢复的各种寄存器数据。

## 任务控制块（TCB）

操作系统需要有效管理每个任务的状态和信息，这依赖于一种数据结构，称为任务控制块（Task Control Block，TCB）。TCB用于记录任务的状态和其他管理信息，并在任务切换时提供完整的任务上下文。

- **任务标识信息**：为每个任务分配唯一的标识符（如TID，任务ID）。
- **处理器现场信息**：保存任务执行状态的寄存器、程序计数器等信息。
- **任务控制信息**：管理任务状态，如正在运行（running）、就绪（ready）或休眠（sleep）等。

通过TCB，操作系统能够在任务间进行有效的上下文切换，确保不同任务在各自的状态下继续执行。

## 小结

任务的组成和管理需要依赖于状态信息的保存和切换。通过任务控制块，操作系统能够跟踪和管理任务的执行状态，实现有效的任务上下文切换，并在任务执行时保持执行过程的一致性。





# 任务状态与切换过程

任务在执行过程中会经历不同的状态，这些状态与任务的执行相关，并在操作系统中被清晰地管理。以下是任务状态及其切换过程的简要总结：

## 任务状态

1. **创建状态**：任务在被创建时，任务控制块（TCB）和相关资源尚未准备好。操作系统为任务创建初始的栈、寄存器和代码空间，设置初始状态，使其具备执行条件。此时，任务处于“创建状态”。

2. **就绪状态**：创建完成后，任务进入就绪状态（Ready），意味着它已准备好执行。就绪任务在等待操作系统的调度，直到系统选择该任务执行时，它才会从就绪状态进入运行状态。

3. **运行状态**：就绪任务被操作系统调度后，将从就绪状态切换到运行状态（Running）。操作系统通过上下文切换，让当前运行的任务让出CPU，并将其分配给新调度的任务。操作系统需要将状态从内核态切换到用户态，使任务代码能够执行。

4. **等待状态**：运行中的任务可能会进入等待状态（Waiting），例如当任务需要等待外部资源时。常见的等待场景包括：
   - **Sleep**：任务主动请求休眠，例如调用“sleep 5秒”。
   - **I/O等待**：等待文件读写或其他外部设备操作完成。由于I/O速度较慢，任务会主动放弃CPU，进入等待状态，使其他任务可以使用CPU。

5. **终止状态**：任务完成其功能或因某种原因被终止，将进入终止状态（Terminated）。此时，任务的资源将被操作系统回收，以供其他任务使用。

## 状态切换过程

1. **创建到就绪**：任务在创建完成后，由操作系统分配资源，使其具备执行条件，并进入就绪状态。

2. **就绪到运行**：操作系统通过调度机制选择一个就绪任务，让其获得CPU执行，任务从就绪状态切换到运行状态。

3. **运行到等待**：当任务需要等待某个事件完成（如休眠或I/O操作），任务将从运行状态切换到等待状态，并让出CPU。

4. **等待到就绪**：等待的事件结束或任务被唤醒后，任务重新进入就绪状态，等待下一次调度执行。

5. **运行到终止**：任务执行完成或被终止时，将从运行状态切换到终止状态，操作系统将释放该任务的资源。

通过这种状态切换机制，操作系统能够有效管理和调度任务，使其在合适的时机获取资源并执行其功能。







# 任务的抢占与状态转换

在多任务操作系统中，任务的状态会不断变化，有时可能会被抢占。以下是任务的抢占、状态转换以及系统调用之间的关系。

## 抢占

抢占是指操作系统强制停止当前正在运行的任务，让它从运行状态转换到就绪状态，以便给其他任务提供运行的机会。抢占通常由时钟中断触发，操作系统在中断发生时将当前任务置于就绪状态，为其他任务的调度和执行腾出资源。

- **时钟中断**：时钟中断是一种周期性中断，用于触发抢占。在时钟中断发生时，操作系统暂停当前任务的执行，将其从运行状态置为就绪状态，然后选择其他任务执行。

## 任务退出

任务退出可以是自愿的或被迫的：

1. **自愿退出**：任务主动调用退出指令（如`exit`系统调用），结束自身的执行。这通常发生在任务完成预定工作后主动请求退出。

2. **被迫退出**：
   - **非法操作**：任务尝试执行非法操作或触发严重错误，操作系统会终止该任务的执行。
   - **外部强制**：更高级别的管理程序或系统管理员可能会强制终止任务的执行。

## 任务模型

任务在执行过程中主要存在以下三种状态：

1. **就绪**：任务已具备执行条件，等待操作系统的调度以获得CPU时间。
2. **运行**：任务正在CPU上执行。
3. **等待**：任务由于需要等待资源（如I/O操作）或休眠等原因而暂停执行。

此外，还有两个额外的过程：

1. **创建**：创建任务时，操作系统分配并初始化任务控制块（TCB）等资源。
2. **退出**：任务结束执行后，操作系统回收资源，将任务控制块和其他资源释放。

这形成了任务状态的五个基本过程：创建、就绪、运行、等待和退出。

## 系统调用与状态转换

系统调用是用户程序与操作系统交互的主要方式，会导致任务状态发生变化：

- **运行到退出**：任务主动调用`exit`系统调用，退出并释放资源。
- **运行到等待**：任务可能通过系统调用进入等待状态，如调用`sleep`使任务休眠一段时间。
- **运行到就绪**：通常由中断触发的抢占或高优先级任务到来，使当前任务暂停并进入就绪状态。

## 总结

任务在操作系统中会经历多种状态转换，包括抢占、系统调用或异常等原因导致的状态变化。了解任务状态及转换的原因，有助于掌握操作系统中任务管理的核心逻辑和实现机制。





# 任务切换的时机与过程

任务在操作系统中进行切换是不可避免的，确保了多任务的并发执行和资源的合理分配。以下是任务何时会进行切换的时机及其过程。

## 任务切换的时机

任务切换是指操作系统暂停当前运行的任务，并在合适的时机切换到其他任务继续执行。主要有以下几个时机：

1. **主动进入等待状态**：当任务调用`sleep`或其他系统调用以进入等待状态（如等待I/O操作），操作系统将任务状态置为等待，进而切换到下一个就绪任务执行。

2. **时间片用尽**：在多任务操作系统中，每个任务被分配一个固定时间片（time slice）。当任务用完时间片，时钟中断触发抢占，操作系统将当前任务置为就绪状态，然后切换到下一个就绪任务执行。

3. **任务退出**：任务执行完毕或被迫退出后，操作系统将当前任务状态置为终止，并切换到下一个就绪任务执行。

## 任务切换的过程

任务切换涉及暂停当前任务并恢复新任务的执行环境，确保任务状态的一致性。任务切换的步骤如下：

1. **保存当前任务的现场**：操作系统在中断或系统调用发生时将当前任务的上下文（context）信息保存至任务控制块（TCB），包括程序计数器、通用寄存器、栈指针等。

2. **选择下一个任务**：操作系统根据调度算法选择下一个就绪任务进行执行。

3. **恢复新任务的现场**：从新任务的任务控制块中恢复其上下文信息，包括程序计数器、寄存器、栈等。

4. **切换到新任务**：操作系统将控制权交给新任务，恢复用户态并开始执行任务的代码。

## 任务切换的简单结构

可以将任务切换的过程形象化为一个结构图：

1. **程序A与程序B**：假设有两个程序在执行任务。任务A主动调用`sleep`系统调用进入等待状态，触发任务切换过程。

2. **进入内核态**：操作系统将通过中断或系统调用进入内核态，保存任务A的上下文信息。

3. **选择下一个任务**：操作系统根据调度算法选择任务B执行，并恢复其上下文。

4. **返回用户态**：操作系统将控制权交给任务B，使其从用户态开始执行。

这种任务切换的结构图展示了任务的上下文保存和恢复过程，以及多任务之间的交替执行机制。

---

下一节

# 实践：多道程序与分时多任务操作系统

分时多任务操作系统通过多阶段的改进，实现了更高效的任务切换和资源利用。以下是各个阶段的变化与任务切换的实践方法。

## 第一阶段：引入任务管理

1. **应用程序管理模块的拆分**：内核中的应用程序管理模块被拆分为不同的子模块，其中引入了程序加载器（loader），负责查找和加载程序。任务切换模块（task manager）则用于管理任务控制块（TCB），独立处理任务切换逻辑。

2. **多任务支持**：引入任务管理后，操作系统可以同时在内存中运行多个应用程序，并实现任务间的切换。这是最早期的多任务系统设计，其中引入了基本的任务结构和管理概念。

## 第二阶段：主动任务切换

1. **系统调用支持主动切换**：在这个阶段，系统调用被扩展，增加了任务放弃与切换的功能。任务可以通过系统调用主动放弃对CPU的占用，切换到其他任务执行。

2. **上下文保存与恢复**：在任务主动放弃CPU时，操作系统保存当前任务的上下文信息（包括寄存器、栈、程序计数器等），并恢复下一个被调度的任务的上下文。

3. **任务调度**：此阶段的操作系统在系统调用中主动管理任务的上下文，并通过任务管理模块实现多任务的调度与切换。

## 第三阶段：中断与时间片管理

1. **引入时钟中断**：操作系统在此阶段引入了时钟中断机制。通过时钟中断，系统可以准确追踪任务的执行时间，为任务分配固定的时间片（time slice）。

2. **时间片切换**：一旦时钟中断指示某个任务的时间片已用尽，操作系统将保存当前任务的上下文，并切换到下一个就绪任务。

3. **统一异常、系统调用与中断处理**：系统调用、中断和异常在本质上都是从用户态切换到内核态的过程。在这个阶段，操作系统统一了它们的处理流程，使它们共用相同的机制来保存和恢复上下文信息。

4. **任务执行时间追踪**：操作系统通过时钟中断追踪每个任务的执行时间，确保任务不会长期独占CPU，保证任务之间的公平调度。

通过这三个阶段的逐步改进，操作系统在管理任务时具备更强的灵活性和效率，实现了真正意义上的多道程序与分时多任务操作系统。







